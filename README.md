# -
大厂面试总结
# 2021/05/07 阿里一面 
C++：
    
    1.STL 中常用的容器，vector 的扩容过程，map 中的key 是否有序，如何实现无序的map
        
        vector使用动态分配的数组存储其元素,为了支持随机访问，vector将元素连续存储。如果没有空间容纳新元素，容器必须分配新的内存空间来保存已有元素和新元素，
        将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。
        
        减少容器空间重新分配次数的策略：
            当不得不获取新的内存空间时，vector和string通常会分配比新空间需求更大的内存空间，作为备用。
        map 的key是有序的，底层是通过二叉搜索树实现的，提供成员函数来高效地插入、搜索和删除键值对。
        
        如何实现无序的map:
            新标准定义了4个无序关联容器，容器不是使用比较运算符组织元素，而是使用哈希函数和关键字类型胡==运算符。无序map在存储上组织为一组桶，每个桶保存零个或者多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜出哪个桶。容器将具有一个特定哈希值的所有元素存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。
    
    2.C++ 类型转换（不是基本数据类型的强制转换 int x =（int）3.7）
        
        算术转换：将一种算术类型转换成另外一种算术类型。算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换为最宽的类型。
        其他隐式类型转换：
            
            数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针
                           int ia[10];//含有10个整数的数组
                           int* ip = ia;// ia转换成指向数组首元素的指针
                           当数组被用作decltype 关键字的参数，或者作为取地址运算符（&），sizeof及typeid等运算符的对象时，或者用一个引用来初始化数组，上述转换也不会发生。表达式中使用函数类型会发生类似的指针转换。
            
            指针的转换：
                           C++ 还规定了几种其他的指针转换方式，包括常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常常量的指针能转换成void*;指向任意对象的指针能转换成const void*。此外还有派生类到基类的转换：因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能用基类的指针或引用绑定到派生类对象中的基类部分上。
                           Quote item；//基类对象
                           Bulk_quote bulk;
                           Quote *p = &item; //p指向Quote对象
                           p = &bulk;// p指向bulk的Quote部分
                           Quote &r = bulk；//r绑定到bulk的Quote部分
            转换成bool类型：
                           存在一种从算术类型或者指针类型向布尔类型自动转换的机制。如果指针或算术类型或者字符类型的值为0或空字符,转换结果是false;否则转换结果为true。
            转换成常量：
                           许将指向非常量类型的指针转换成相应的常量类型的指针。对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换为指向const T的指针或引用。相反的转换并不存在，因为它试图删除底层const。
            类类型定义的转换：
                           类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。如果类的构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制
                           注：
                                只允许做一步类类型转换：
                                //(1)把“9-99999-9”转换成string
                                //(2)再把这个（临时的）string转换成Scales_data
                                item.combine("9-99999-9");
                                如果我们想完成上述调用，可以显示地把字符串转换成string或者Scales_data对象：
                                //正确：显式转换成string,隐式地转换成Sales_data
                                item.combine(string("9-99999-9"));
                                //正确：隐式转换string,显式地转换成Sales_data
                                item.combine(Sales_data("9-99999-9"));
    3.C++ 如何实现进程间通信
    
    4.C++ 测试工具用过那些
    
    5.C++ malloc 如何管理内存
    
    6.C++11引入的interprter
    
    7.试图实例化抽象基类（含有纯虚函数），会发生什么？
数据库：

    1.使用SQLite开发单机软件时，如何备份数据，SQLite的特点
    2.   
# 2021/05/17 好未来一面
    1. 返回链表的中间节点的值（尽可能多的方法）
        辅助数组+计数器
        快慢指针
    2. 智能指针了解多少？
    
    3. C++虚函数表

    4.第三范式
        不能存在传递依赖
    5.STL的有哪些？vector 扩容过程
# 2021/05/18 完美世界一面
    1.vector 与 map 的区别?如何解决哈希冲突？
    处理冲突的思路：
        换个位置：开放地址法
        同一位置的冲突对象组织在一起：链地址法
    开放定址法：h(key) = ((h(key)+d) MOD m)(m为哈希表的表长，d为增量)当得出的哈希地址产生冲突时国，选取以下3种方法获取d值，然后继续计算，直到计算出的哈希地址不存在冲突为止;
            线性探测：d =1,2,3,4,5,6,7
            二次探测法：d=-1,1,4,-4,...
            伪随机数探测：d = 伪随机数
            再哈希法：d = d*h2(key)
    链地址法：将所有产生冲突的关键字所对应的数据全部存储在一个链表中。

    建立一个公共溢出区：
            建立两张表，一张为基本表。基本表存储没有发生冲突的数据，当关键字由哈希函数生成的哈希地址产生冲突时，就将数据填入溢出表。



    2.vector在应用层可见的是物理内存还是虚拟内存?
    3.虚拟内存与物理内存相比有那些好处？
        虚拟内存地址不是真实的物理地址，虚拟地址通过CPU的转换才能对应到物理地址，而且每次运行程序时，操作系统都会重新安排虚拟地址与物理地址的对应关系，哪一段物理内存空闲就使用哪一段。
        
        1.使不同程序的地址空间相互隔离
            使用了虚拟地址后，程序A和程序B虽然都可以访问同一个地址，但他们对应的物理地址是不同的，无论如何操作，都不会修改对方内存。
        2.提高内存使用效率
            使用虚拟地址后，操作系统会更多地介入到内存管理中，这使得控制内存权限成为可能。
            另外，当物理内存不足时，操作系统能更加灵活地控制换入换出的粒度，磁盘I/O是非常耗时的工作，这能从很大程度上提高程序性能。


    4.vector 的扩容策略?
    5.骨骼动画中，如何解决旋转（等）过后，坐标轴发生变化的问题？
    6.OPENGL 渲染管线 如何将三角形的顶点传入GPU（哪个API）
    glBufferData()
    7.相机坐标与世界坐标之间的关系？
    8.多级渐远纹理，如何确定适合的纹理？
    9.为神魔三维向量坐标变换要用四维坐标（平移，旋转，缩放，透视变换）？
        
    10.光栅化过程，插值方法（如：对三角形的顶点插值）
    11.
# 2020/05/28 小米一面
    1.n个有序链表合并成一个链表（归并）
    2.输出二叉树指定和的路径（回溯）
    3.C++ 11:引入的函数有哪些？
        移动构造函数，move,forward
    4.move:如何实现将左值引用转换为右值引用？
        通过移动构造函数
    5.shard_ptr 中引用计数由谁来管理（内存分配与释放）类本身还是？
        对象本身
    6.如果基类中未将析构函数声明为virtual，销毁子类的对象会怎么样？
        不声明virtual，就没有虚函数表，会造成内存泄漏
    7.weak_ptr 是用来解决什么问题？（）
        循环引用
    8.线程与进程的区别？
    9.多线程：锁：unique_lock
    10.TCP为什么是三次握手，四次挥手？
        三次握手：
        1)是为了确认自己有发送和接收能力，并且对方也有发送和接收能力
        2)避免已过期的连接请求报文突然又传送到服务器，而客户端已经关闭导致服务长时间单方面等待，造成资源浪费。
        3）告诉对方自己的初始序号值，并确认收到对方的初始序号值 
        四次挥手：
        服务器在收到客户端的FIN报文后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回ACK报文段。
        数据发送完成之后，服务器会向客户端发送FIN报文，表示数据已经接收完毕，请求关闭连接。客户端收到请关闭求之后，与服务器确认，服务器关闭连接。
    11.为什么客户端的TIME-WAIT状态必须等待2MSL？（超时重传）
        1)确保ACK报文能够到达服务端，从而使服务器正常关闭连接。
        第四次挥手时，客户端第四次挥手的ACK报文不一定会到达服务端。服务端会超时重传FIN/ACK报文，此时如果客户端断开了连接，那么就无法响应服务器的二次请求，这样服务端迟迟收不到FIN/ACK报文的确认，就无法正常断开连接。
        2MSL = 客户端ACK报文确认+服务端FIN/ACK 1MSL
# 2020/05/28 广联达一面
    1.判断链表是否有环？
        快慢指针
    2.判断链表是否相交？
        寻找共同的节点
    3.一个非常非常大的单向链表，没有足够的空间存储，如何返回链表第五个节点的值？
        两个指针，先让前面的指针走五步（前后指针相差5），然后前后指针相同的步长往后走
    4.list的迭代器end()的值++会返回什么？是空指针嘛？
    5.设计模式：解释工厂模式
        我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”
    6.试图用NULL 初始化一个人Test类类型的指针，会发生什么？
        class Test{
            Test()
            public:
                {
                    cout << "helloworld";
                }
                void set()
                {
                    cout<<"hahaha"
                }
        }
        Test* t = NULL;
        t->set();
        程序运行结果：hahaha
    7.解释一下几种光照的区别（OPENGL）
#2021/05/23 百度两面
    1 ORM
    2 层序遍历
    3 快排
    4 dfs
    5 SQLite的特点
    
    
